{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pathfinder CloudEvents Microservice","text":"<p>Receives RestApi requests from Pathfinder, converts them into RaBe CloudEvents, and stores the resulting CloudEvent in a Kafka topic.</p> <p>This service aims at replacing the previous LWRP based implementation which itself was highly influenced by the original serial implementation that was carried over to the digital domain during our analog to digital migration in an effort to reduce the migrations blast radius.</p>"},{"location":"#usage","title":"Usage","text":"<p>The service is deployed to our container infrastructure and it provides a <code>/webhook</code> endpoint that receives POST requests from Pathfinder. The body of this request contains information in a query string style, specifically Pathfinder sends us a <code>event</code> and <code>channel</code> value. The <code>event</code> is either <code>OnAir</code> or <code>OffAir</code> and the channel indicates which audio source is currently routed to our broadcast infrastructure.</p> <p>Information on available configuration options is available via the <code>--help</code> argument:</p> <pre><code>podman run --rm ghcr.io/radiorabe/pathfinderevents pathfinderevents --help\n</code></pre>"},{"location":"#links","title":"Links","text":"<ul> <li>Pathfinder RestApi documentation</li> </ul>"},{"location":"#release-management","title":"Release Management","text":"<p>The CI/CD setup uses semantic commit messages following the conventional commits standard. The workflow is based on the RaBe shared actions and uses go-semantic-commit to create new releases.</p> <p>The commit message should be structured as follows:</p> <pre><code>&lt;type&gt;[optional scope]: &lt;description&gt;\n\n[optional body]\n\n[optional footer(s)]\n</code></pre> <p>The commit contains the following structural elements, to communicate intent to the consumers of your library:</p> <ol> <li>fix: a commit of the type <code>fix</code> patches gets released with a PATCH version bump</li> <li>feat: a commit of the type <code>feat</code> gets released as a MINOR version bump</li> <li>BREAKING CHANGE: a commit that has a footer <code>BREAKING CHANGE:</code> gets released as a MAJOR version bump</li> <li>types other than <code>fix:</code> and <code>feat:</code> are allowed and don't trigger a release</li> </ol> <p>If a commit does not contain a conventional commit style message you can fix it during the squash and merge operation on the PR.</p>"},{"location":"#build-process","title":"Build Process","text":"<p>The CI/CD setup uses Docker build-push Action  to publish container images. The workflow is based on the RaBe shared actions.</p>"},{"location":"#license","title":"License","text":"<p>This application is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, version 3 of the License.</p>"},{"location":"#copyright","title":"Copyright","text":"<p>Copyright (c) 2023 Radio Bern RaBe</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>pathfinderevents</li> </ul>"},{"location":"reference/pathfinderevents/","title":"pathfinderevents","text":""},{"location":"reference/pathfinderevents/#pathfinderevents.ApiServer","title":"<code>ApiServer</code>","text":"<p>The API server.</p> Source code in <code>pathfinderevents.py</code> <pre><code>class ApiServer:\n    \"\"\"The API server.\"\"\"\n\n    def __init__(\n        self,\n        bind_addr: str,\n        bind_port: int,\n        realm: str,\n        topic: str,\n        username: str,\n        password: str,\n        debug: bool = False,\n    ):\n        self.producer: KafkaProducer\n        self.bind_addr: str = bind_addr\n        self.bind_port: int = bind_port\n        self.realm = realm\n        self.topic = topic\n        self.username = username\n        self.password = password\n        self.debug = debug\n\n        self.url_map = Map([Rule(\"/webhook\", endpoint=\"webhook\")])\n\n    def set_producer(self, producer: KafkaProducer):\n        self.producer = producer\n\n    def run_server(self):\n        \"\"\"Run the API server.\"\"\"\n        if not self.producer:\n            raise RuntimeError(\"run_server called before set_producer\")\n        if self.debug:\n            from werkzeug.serving import run_simple\n\n            self._server = run_simple(\n                self.bind_addr,\n                self.bind_port,\n                self,\n                use_debugger=True,\n                use_reloader=True,\n            )\n        else:  # pragma: no cover\n            cherrypy.tree.graft(self, \"/\")\n            cherrypy.server.unsubscribe()\n\n            self._server = cherrypy._cpserver.Server()\n\n            self._server.socket_host = self.bind_addr\n            self._server.socket_port = self.bind_port\n\n            self._server.subscribe()\n\n            cherrypy.engine.start()\n            cherrypy.engine.block()\n\n    def stop_server(self):\n        \"\"\"Stop the server.\"\"\"\n        self._server.stop()\n        cherrypy.engine.exit()\n\n    def __call__(self, environ, start_response):\n        return self.wsgi_app(environ, start_response)\n\n    def wsgi_app(self, environ, start_response):\n        request = Request(environ)\n        auth = request.authorization\n        if auth and self.check_auth(auth.username, auth.password):\n            response = self.dispatch_request(request)\n        else:\n            response = self.auth_required(request)\n        return response(environ, start_response)\n\n    def check_auth(self, username, password):\n        \"\"\"Check plaintext auth.\n\n        Pathfinder doesn't support sending any advanced API credentials like JWT or\n        similar so we resort to the most insecure way possible to authenticate its\n        requests.\n        \"\"\"\n        return self.username == username and self.password == password\n\n    def auth_required(self, request):\n        \"\"\"Return a 401 unauthorized reponse.\"\"\"\n        return Response(\n            \"Could not verify your access level for that URL.\\n\"\n            \"You have to login with proper credentials\",\n            status=401,\n            headers={\"WWW-Authenticate\": f'Basic realm=\"{self.realm}\"'},\n        )\n\n    def dispatch_request(self, request):\n        \"\"\"Dispatch request and return any errors in response.\"\"\"\n        adapter = self.url_map.bind_to_environ(request.environ)\n        try:\n            endpoint, values = adapter.match()\n            return getattr(self, f\"on_{endpoint}\")(request, **values)\n        except HTTPException as e:\n            return Response(\n                json.dumps(e.description),\n                e.code,\n                {\"Content-Type\": \"application/json\"},\n            )\n\n    def on_webhook(self, request):\n        \"\"\"Receive a Pathfinder RestApi call and produce a CloudEvent.\"\"\"\n\n        def on_send_error(ex):  # pragma: no cover\n            logger.error(\"Failed to send CloudEvent\", exc_info=ex)\n\n        ce = from_pathfinder_request(request)\n        kafka_msg = to_structured(\n            ce,\n            key_mapper=lambda event: \".\".join(\n                [\n                    ce.get(\"type\"),\n                    ce.get(\"subject\"),\n                ]\n            ),\n        )\n        self.producer.send(\n            self.topic,\n            key=kafka_msg.key,\n            value=kafka_msg.value,\n            headers=kafka_msg.headers if kafka_msg.headers else None,\n        ).add_errback(on_send_error)\n        self.producer.flush()\n        logger.info(\n            f\"Forwarded event {ce.get('type')} with channel {ce.get('subject')}\"\n        )\n        return Response(\n            status=\"200 Event Received\",\n        )\n</code></pre>"},{"location":"reference/pathfinderevents/#pathfinderevents.ApiServer.auth_required","title":"<code>auth_required(request)</code>","text":"<p>Return a 401 unauthorized reponse.</p> Source code in <code>pathfinderevents.py</code> <pre><code>def auth_required(self, request):\n    \"\"\"Return a 401 unauthorized reponse.\"\"\"\n    return Response(\n        \"Could not verify your access level for that URL.\\n\"\n        \"You have to login with proper credentials\",\n        status=401,\n        headers={\"WWW-Authenticate\": f'Basic realm=\"{self.realm}\"'},\n    )\n</code></pre>"},{"location":"reference/pathfinderevents/#pathfinderevents.ApiServer.check_auth","title":"<code>check_auth(username, password)</code>","text":"<p>Check plaintext auth.</p> <p>Pathfinder doesn't support sending any advanced API credentials like JWT or similar so we resort to the most insecure way possible to authenticate its requests.</p> Source code in <code>pathfinderevents.py</code> <pre><code>def check_auth(self, username, password):\n    \"\"\"Check plaintext auth.\n\n    Pathfinder doesn't support sending any advanced API credentials like JWT or\n    similar so we resort to the most insecure way possible to authenticate its\n    requests.\n    \"\"\"\n    return self.username == username and self.password == password\n</code></pre>"},{"location":"reference/pathfinderevents/#pathfinderevents.ApiServer.dispatch_request","title":"<code>dispatch_request(request)</code>","text":"<p>Dispatch request and return any errors in response.</p> Source code in <code>pathfinderevents.py</code> <pre><code>def dispatch_request(self, request):\n    \"\"\"Dispatch request and return any errors in response.\"\"\"\n    adapter = self.url_map.bind_to_environ(request.environ)\n    try:\n        endpoint, values = adapter.match()\n        return getattr(self, f\"on_{endpoint}\")(request, **values)\n    except HTTPException as e:\n        return Response(\n            json.dumps(e.description),\n            e.code,\n            {\"Content-Type\": \"application/json\"},\n        )\n</code></pre>"},{"location":"reference/pathfinderevents/#pathfinderevents.ApiServer.on_webhook","title":"<code>on_webhook(request)</code>","text":"<p>Receive a Pathfinder RestApi call and produce a CloudEvent.</p> Source code in <code>pathfinderevents.py</code> <pre><code>def on_webhook(self, request):\n    \"\"\"Receive a Pathfinder RestApi call and produce a CloudEvent.\"\"\"\n\n    def on_send_error(ex):  # pragma: no cover\n        logger.error(\"Failed to send CloudEvent\", exc_info=ex)\n\n    ce = from_pathfinder_request(request)\n    kafka_msg = to_structured(\n        ce,\n        key_mapper=lambda event: \".\".join(\n            [\n                ce.get(\"type\"),\n                ce.get(\"subject\"),\n            ]\n        ),\n    )\n    self.producer.send(\n        self.topic,\n        key=kafka_msg.key,\n        value=kafka_msg.value,\n        headers=kafka_msg.headers if kafka_msg.headers else None,\n    ).add_errback(on_send_error)\n    self.producer.flush()\n    logger.info(\n        f\"Forwarded event {ce.get('type')} with channel {ce.get('subject')}\"\n    )\n    return Response(\n        status=\"200 Event Received\",\n    )\n</code></pre>"},{"location":"reference/pathfinderevents/#pathfinderevents.ApiServer.run_server","title":"<code>run_server()</code>","text":"<p>Run the API server.</p> Source code in <code>pathfinderevents.py</code> <pre><code>def run_server(self):\n    \"\"\"Run the API server.\"\"\"\n    if not self.producer:\n        raise RuntimeError(\"run_server called before set_producer\")\n    if self.debug:\n        from werkzeug.serving import run_simple\n\n        self._server = run_simple(\n            self.bind_addr,\n            self.bind_port,\n            self,\n            use_debugger=True,\n            use_reloader=True,\n        )\n    else:  # pragma: no cover\n        cherrypy.tree.graft(self, \"/\")\n        cherrypy.server.unsubscribe()\n\n        self._server = cherrypy._cpserver.Server()\n\n        self._server.socket_host = self.bind_addr\n        self._server.socket_port = self.bind_port\n\n        self._server.subscribe()\n\n        cherrypy.engine.start()\n        cherrypy.engine.block()\n</code></pre>"},{"location":"reference/pathfinderevents/#pathfinderevents.ApiServer.stop_server","title":"<code>stop_server()</code>","text":"<p>Stop the server.</p> Source code in <code>pathfinderevents.py</code> <pre><code>def stop_server(self):\n    \"\"\"Stop the server.\"\"\"\n    self._server.stop()\n    cherrypy.engine.exit()\n</code></pre>"},{"location":"reference/pathfinderevents/#pathfinderevents.app","title":"<code>app(api, bootstrap_servers, security_protocol, tls_cafile, tls_certfile, tls_keyfile, topic, max_messages=0)</code>","text":"<p>Set up pathfinder subscription and kafka producer, blocks while processing messages.</p> Source code in <code>pathfinderevents.py</code> <pre><code>def app(\n    api: ApiServer,\n    bootstrap_servers: list[str],\n    security_protocol: str,\n    tls_cafile: str,\n    tls_certfile: str,\n    tls_keyfile: str,\n    topic: str,\n    max_messages: int = 0,\n):\n    \"\"\"\n    Set up pathfinder subscription and kafka producer, blocks while processing messages.\n    \"\"\"\n    producer = KafkaProducer(\n        bootstrap_servers=bootstrap_servers,\n        security_protocol=security_protocol,\n        retries=5,\n        max_in_flight_requests_per_connection=1,\n        key_serializer=lambda k: bytes(k, \"utf-8\"),\n        ssl_cafile=tls_cafile,\n        ssl_certfile=tls_certfile,\n        ssl_keyfile=tls_keyfile,\n    )\n    api.set_producer(producer)\n\n    def on_sigint(*_):  # pragma: no cover\n        api.stop_server()\n        producer.flush()\n        producer.close()\n        sys.exit(0)\n\n    signal.signal(signal.SIGINT, on_sigint)\n\n    api.run_server()  # blocking\n    producer.flush()\n    producer.close()\n</code></pre>"},{"location":"reference/pathfinderevents/#pathfinderevents.from_pathfinder_request","title":"<code>from_pathfinder_request(request)</code>","text":"<p>Convert a basic pathfinder POST request's data into a proper CloudEvent.</p> Source code in <code>pathfinderevents.py</code> <pre><code>def from_pathfinder_request(request: Request) -&gt; CloudEvent:\n    \"\"\"Convert a basic pathfinder POST request's data into a proper CloudEvent.\"\"\"\n    form = parse_qs(request.get_data(as_text=True))\n    return CloudEvent(\n        {\n            \"type\": f\"ch.rabe.api.events.pathfinder.v0alpha1.{form['event'][0]}\",\n            \"source\": \"https://github.com/radiorabe/pathfinder-cloudevents-service\",\n            \"subject\": form[\"channel\"][0],\n            \"datacontenttype\": \"text/plain\",\n        },\n        form[\"channel\"][0],\n    )\n</code></pre>"},{"location":"reference/pathfinderevents/#pathfinderevents.main","title":"<code>main()</code>","text":"<p>CLI entrypoint parses args, sets up logging, and calls <code>app()</code>.</p> Source code in <code>pathfinderevents.py</code> <pre><code>def main():  # pragma: no cover\n    \"\"\"\n    CLI entrypoint parses args, sets up logging, and calls `app()`.\n    \"\"\"\n    parser = ArgumentParser(\n        __name__,\n        config_file_parser_class=YAMLConfigFileParser,\n        default_config_files=[f\"{__name__}.yaml\"],\n    )\n    parser.add(\n        \"--bind-addr\",\n        default=\"0.0.0.0\",\n        env_var=\"APP_BIND_ADDR\",\n    )\n    parser.add(\n        \"--bind-port\",\n        default=8080,\n        env_var=\"APP_BIND_PORT\",\n    )\n    parser.add(\n        \"--realm\",\n        default=\"pathfinder\",\n        env_var=\"APP_REALM\",\n    )\n    parser.add(\n        \"--username\",\n        default=\"pathfinder\",\n        env_var=\"APP_USERNAME\",\n    )\n    parser.add(\n        \"--password\",\n        required=True,\n        env_var=\"APP_PASSWORD\",\n    )\n    parser.add(\n        \"--kafka-bootstrap-servers\",\n        required=True,\n        env_var=\"KAFKA_BOOTSTRAP_SERVERS\",\n    )\n    parser.add(\n        \"--kafka-security-protocol\",\n        default=\"PLAINTEXT\",\n        env_var=\"KAFKA_SECURITY_PROTOCOL\",\n    )\n    parser.add(\n        \"--kafka-tls-cafile\",\n        default=None,\n        env_var=\"KAFKA_TLS_CAFILE\",\n    )\n    parser.add(\n        \"--kafka-tls-certfile\",\n        default=None,\n        env_var=\"KAFKA_TLS_CERTFILE\",\n    )\n    parser.add(\n        \"--kafka-tls-keyfile\",\n        default=None,\n        env_var=\"KAFKA_TLS_KEYFILE\",\n    )\n    parser.add(\n        \"--kafka-topic\",\n        default=\"dev.cloudevents\",\n        env_var=\"KAFKA_TOPIC\",\n    )\n    parser.add(\n        \"--quiet\",\n        \"-q\",\n        default=False,\n        action=\"store_true\",\n        env_var=\"QUIET\",\n    )\n    parser.add(\n        \"--debug\",\n        default=False,\n        action=\"store_true\",\n        env_var=\"DEBUG\",\n    )\n\n    options = parser.parse_args()\n\n    if not options.quiet:\n        logging.basicConfig(level=logging.INFO)\n    if options.debug:\n        logging.basicConfig(level=logging.DEBUG)\n    logger.info(f\"Starting {__name__}...\")\n\n    app(\n        api=ApiServer(\n            bind_addr=options.bind_addr,\n            bind_port=options.bind_port,\n            realm=options.realm,\n            username=options.username,\n            password=options.password,\n            topic=options.kafka_topic,\n            debug=options.debug,\n        ),\n        bootstrap_servers=options.kafka_bootstrap_servers,\n        security_protocol=options.kafka_security_protocol,\n        tls_cafile=options.kafka_tls_cafile,\n        tls_certfile=options.kafka_tls_certfile,\n        tls_keyfile=options.kafka_tls_keyfile,\n        topic=options.kafka_topic,\n    )\n</code></pre>"}]}